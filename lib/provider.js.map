{"version":3,"sources":[".././src/provider.js","../external \"events\"","../external \"os\"","../external \"child_process\"",".././src/config.js",".././node_modules/atom-package-deps/lib/index.js","../external \"fs\"","../external \"path\"",".././node_modules/atom-satisfy-dependencies/lib/index.js",".././node_modules/atom-read-manifest/lib/index.js",".././node_modules/caller-callsite/index.js",".././node_modules/callsites/index.js",".././src/util.js","../webpack/bootstrap","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/startup"],"names":["provideBuilder","SasscProvider","EventEmitter","constructor","cwd","atom","config","observe","meta","emit","getNiceName","isEligible","getConfig","cmd","spawnSync","which","stdout","toString","settings","errorMatch","pathToSass","customArguments","trim","split","name","exec","args","sh","atomCommandName","activate","satisfyDependencies","configSchema","title","description","type","default","order","manageDependencies","alwaysEligible","key","get","platform"],"mappings":"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CA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA,iBAAiB,iBAAiB;AAClC;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA,QAAQ,YAAY;;AAEpB;AACA,sFAAsF,YAAY,MAAM,mBAAmB;AAC3H;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,iBAAiB;AACjC;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,oBAAoB;AAC/C;AACA;AACA,wBAAwB;AACxB;AACA;AACA,uBAAuB;AACvB;AACA;AACA,uBAAuB;AACvB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG,YAAY;AACf;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG,YAAY;AACf;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+DAA+D,KAAK;AACpE;AACA;AACA;AACA,+CAA+C,MAAM,GAAG,SAAS,OAAO,KAAK;AAC7E;AACA;AACA,SAAS;AACT,iDAAiD,MAAM,OAAO,KAAK;AACnE,OAAO;AACP,6CAA6C,MAAM,OAAO,KAAK;AAC/D;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA,qEAAqE,KAAK;AAC1E;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2EAA2E;;AAE3E;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA,0DAA0D,gBAAgB;AAC1E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA;AACA,uCAAuC,wCAAwC;AAC/E;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;;;AAGP,yCAAyC;;AAEzC;AACA;AACA,6EAA6E,6EAA6E;AAC1J;AACA,OAAO;;;AAGP;AACA;AACA,sDAAsD;;AAEtD;AACA;AACA;AACA;AACA,0DAA0D,2BAA2B;AACrF;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,gEAAgE,YAAY;AAC5E,0BAA0B,+CAA+C;AACzE;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,wDAAwD,gBAAgB;AACxE,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,2DAA2D,YAAY;AACvE,4FAA4F,kBAAkB;AAC9G;AACA,SAAS;AACT,OAAO;AACP,mDAAmD,YAAY;AAC/D,+BAA+B,+CAA+C;AAC9E,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,gFAAgF,YAAY;AAC5F,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,2CAA2C,gCAAgC,UAAU,cAAc;AACnG;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,yCAAyC,gBAAgB;AACzD,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA,qDAAqD;AACrD;AACA,OAAO;AACP;;AAEA,YAAY;AACZ;AACA;AACA,GAAG,GAAG;AACN;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA,eAAe;;;;;;;AC17Bf,gC;;;;;;ACAA,kC;;;;;;;;;;;;ACAa;AACb;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA;AACA,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,2BAA2B;AAC3B,0BAA0B,mBAAO,CAAC,CAAmB;AACrD,2BAA2B,mBAAO,CAAC,EAAoB;AACvD;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,2BAA2B;AAC3B;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iC;;;;;;AClGa;AACb;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;AACA;AACA,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,wBAAwB,GAAG,oBAAoB;AAC/C,SAAS,mBAAO,CAAC,CAAM;AACvB,SAAS,mBAAO,CAAC,CAAI;AACrB,qBAAqB,mBAAO,CAAC,EAAiB;AAC9C;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,oBAAoB;AACpB;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yCAAyC,iBAAiB,EAAE;AAC5D;AACA;AACA;AACA,iC;;;;;;AClGa;AACb,kBAAkB,mBAAO,CAAC,EAAW;;AAErC,mBAAmB,UAAU,KAAK;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACpBa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;;;;;;;;;;;;;ACZtB;AAEO,SAASxB,KAAT,GAAiB;AACtB,SAAO0B,4CAAQ,OAAO,OAAf,GAAyB,OAAzB,GAAmC,OAA1C;AACD,C;;;;;UCJD;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCrBA;WACA;WACA;WACA;WACA;WACA,gCAAgC,YAAY;WAC5C;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,sF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;UCNA;UACA;UACA;UACA","file":"provider.js","sourcesContent":["'use babel';\n\nimport { configSchema, getConfig } from './config';\nimport { EventEmitter } from 'events';\nimport { satisfyDependencies } from 'atom-satisfy-dependencies';\nimport { spawnSync } from 'child_process';\nimport { which } from './util';\nimport meta from '../package.json';\n\nexport { configSchema as config };\n\nexport function provideBuilder() {\n  return class SasscProvider extends EventEmitter {\n    constructor(cwd) {\n      super();\n      this.cwd = cwd;\n      atom.config.observe(`${meta.name}.customArguments`, () =>\n        this.emit('refresh')\n      );\n    }\n\n    getNiceName() {\n      return 'SassC';\n    }\n\n    isEligible() {\n      if (getConfig('alwaysEligible') === true) {\n        return true;\n      }\n\n      const cmd = spawnSync(which(), [getConfig('pathToSass')]);\n      if (!cmd.stdout?.toString()) {\n        return false;\n      }\n\n      return true;\n    }\n\n    settings() {\n      const errorMatch = [\n        '(?<message>Error: .*)\\\\n\\\\s+on line (?<line>\\\\d+) of (?<file>.*)\\\\n'\n      ];\n\n      const pathToSass = getConfig('pathToSass');\n      const customArguments = getConfig('customArguments').trim().split(' ');\n\n      return [\n        {\n          name: 'SassC',\n          exec: pathToSass,\n          args: ['{FILE_ACTIVE}', '{FILE_ACTIVE_NAME_BASE}.css'],\n          cwd: '{FILE_ACTIVE_PATH}',\n          sh: false,\n          atomCommandName: 'sassc:compile',\n          errorMatch: errorMatch\n        },\n        {\n          name: 'SassC (compact)',\n          exec: pathToSass,\n          args: [\n            '--style',\n            'compact',\n            '{FILE_ACTIVE}',\n            '{FILE_ACTIVE_NAME_BASE}.css'\n          ],\n          cwd: '{FILE_ACTIVE_PATH}',\n          sh: false,\n          atomCommandName: 'sassc:compile-compact',\n          errorMatch: errorMatch\n        },\n        {\n          name: 'SassC (compressed)',\n          exec: pathToSass,\n          args: [\n            '--style',\n            'compressed',\n            '{FILE_ACTIVE}',\n            '{FILE_ACTIVE_NAME_BASE}.min.css'\n          ],\n          cwd: '{FILE_ACTIVE_PATH}',\n          sh: false,\n          atomCommandName: 'sassc:compile-compressed',\n          errorMatch: errorMatch\n        },\n        {\n          name: 'SassC (expanded)',\n          exec: pathToSass,\n          args: [\n            '--style',\n            'expanded',\n            '{FILE_ACTIVE}',\n            '{FILE_ACTIVE_NAME_BASE}.css'\n          ],\n          cwd: '{FILE_ACTIVE_PATH}',\n          sh: false,\n          atomCommandName: 'sassc:compile-compressed',\n          errorMatch: errorMatch\n        },\n        {\n          name: 'SassC (user)',\n          exec: pathToSass,\n          args: customArguments,\n          cwd: '{FILE_ACTIVE_PATH}',\n          sh: false,\n          atomCommandName: 'sassc:compile-with-user-settings',\n          errorMatch: errorMatch\n        }\n      ];\n    }\n  };\n}\n\n// This package depends on build, make sure it's installed\nexport async function activate() {\n  if (getConfig('manageDependencies') === true) {\n    satisfyDependencies(meta.name);\n  }\n}\n","module.exports = require(\"events\");;","module.exports = require(\"os\");;","module.exports = require(\"child_process\");;","import meta from '../package.json';\n\nexport const configSchema = {\n  pathToSass: {\n    title: 'Path to Sass',\n    description: 'Specify a custom path to the `sassc` binary',\n    type: 'string',\n    default: 'sassc',\n    order: 0\n  },\n  customArguments: {\n    title: 'Custom Arguments',\n    description:\n      'Specify your preferred arguments for `sassc`, supports [replacement](https://github.com/noseglid/atom-build#replacement) placeholders',\n    type: 'string',\n    default: '--style compressed {FILE_ACTIVE} {FILE_ACTIVE_NAME_BASE}.min.css',\n    order: 1\n  },\n  manageDependencies: {\n    title: 'Manage Dependencies',\n    description:\n      'When enabled, third-party dependencies will be installed automatically',\n    type: 'boolean',\n    default: true,\n    order: 2\n  },\n  alwaysEligible: {\n    title: 'Always Eligible',\n    description:\n      'The build provider will be available in your project, even when not eligible',\n    type: 'boolean',\n    default: false,\n    order: 3\n  }\n};\n\nexport function getConfig(key) {\n  return atom.config.get(`${meta.name}.${key}`);\n}\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar os = require('os');\nvar child_process = require('child_process');\nvar fs = require('fs');\nvar path = require('path');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar os__default = /*#__PURE__*/_interopDefaultLegacy(os);\nvar fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);\nvar path__default = /*#__PURE__*/_interopDefaultLegacy(path);\n\nvar indentString = (string, count = 1, options) => {\n\toptions = {\n\t\tindent: ' ',\n\t\tincludeEmptyLines: false,\n\t\t...options\n\t};\n\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`input\\` to be a \\`string\\`, got \\`${typeof string}\\``\n\t\t);\n\t}\n\n\tif (typeof count !== 'number') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`count\\` to be a \\`number\\`, got \\`${typeof count}\\``\n\t\t);\n\t}\n\n\tif (typeof options.indent !== 'string') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`options.indent\\` to be a \\`string\\`, got \\`${typeof options.indent}\\``\n\t\t);\n\t}\n\n\tif (count === 0) {\n\t\treturn string;\n\t}\n\n\tconst regex = options.includeEmptyLines ? /^/gm : /^(?!\\s*$)/gm;\n\n\treturn string.replace(regex, options.indent.repeat(count));\n};\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/;\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:babel-polyfill|pirates)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/;\nconst homeDir = typeof os__default['default'].homedir === 'undefined' ? '' : os__default['default'].homedir();\n\nvar cleanStack = (stack, options) => {\n\toptions = Object.assign({pretty: false}, options);\n\n\treturn stack.replace(/\\\\/g, '/')\n\t\t.split('\\n')\n\t\t.filter(line => {\n\t\t\tconst pathMatches = line.match(extractPathRegex);\n\t\t\tif (pathMatches === null || !pathMatches[1]) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst match = pathMatches[1];\n\n\t\t\t// Electron\n\t\t\tif (\n\t\t\t\tmatch.includes('.app/Contents/Resources/electron.asar') ||\n\t\t\t\tmatch.includes('.app/Contents/Resources/default_app.asar')\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn !pathRegex.test(match);\n\t\t})\n\t\t.filter(line => line.trim() !== '')\n\t\t.map(line => {\n\t\t\tif (options.pretty) {\n\t\t\t\treturn line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')));\n\t\t\t}\n\n\t\t\treturn line;\n\t\t})\n\t\t.join('\\n');\n};\n\nconst cleanInternalStack = stack => stack.replace(/\\s+at .*aggregate-error\\/index.js:\\d+:\\d+\\)?/g, '');\n\nclass AggregateError extends Error {\n\tconstructor(errors) {\n\t\tif (!Array.isArray(errors)) {\n\t\t\tthrow new TypeError(`Expected input to be an Array, got ${typeof errors}`);\n\t\t}\n\n\t\terrors = [...errors].map(error => {\n\t\t\tif (error instanceof Error) {\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tif (error !== null && typeof error === 'object') {\n\t\t\t\t// Handle plain error objects with message property and/or possibly other metadata\n\t\t\t\treturn Object.assign(new Error(error.message), error);\n\t\t\t}\n\n\t\t\treturn new Error(error);\n\t\t});\n\n\t\tlet message = errors\n\t\t\t.map(error => {\n\t\t\t\t// The `stack` property is not standardized, so we can't assume it exists\n\t\t\t\treturn typeof error.stack === 'string' ? cleanInternalStack(cleanStack(error.stack)) : String(error);\n\t\t\t})\n\t\t\t.join('\\n');\n\t\tmessage = '\\n' + indentString(message, 4);\n\t\tsuper(message);\n\n\t\tthis.name = 'AggregateError';\n\n\t\tObject.defineProperty(this, '_errors', {value: errors});\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const error of this._errors) {\n\t\t\tyield error;\n\t\t}\n\t}\n}\n\nvar aggregateError = AggregateError;\n\nvar pMap = async (\n\titerable,\n\tmapper,\n\t{\n\t\tconcurrency = Infinity,\n\t\tstopOnError = true\n\t} = {}\n) => {\n\treturn new Promise((resolve, reject) => {\n\t\tif (typeof mapper !== 'function') {\n\t\t\tthrow new TypeError('Mapper function is required');\n\t\t}\n\n\t\tif (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {\n\t\t\tthrow new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t\t}\n\n\t\tconst result = [];\n\t\tconst errors = [];\n\t\tconst iterator = iterable[Symbol.iterator]();\n\t\tlet isRejected = false;\n\t\tlet isIterableDone = false;\n\t\tlet resolvingCount = 0;\n\t\tlet currentIndex = 0;\n\n\t\tconst next = () => {\n\t\t\tif (isRejected) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextItem = iterator.next();\n\t\t\tconst index = currentIndex;\n\t\t\tcurrentIndex++;\n\n\t\t\tif (nextItem.done) {\n\t\t\t\tisIterableDone = true;\n\n\t\t\t\tif (resolvingCount === 0) {\n\t\t\t\t\tif (!stopOnError && errors.length !== 0) {\n\t\t\t\t\t\treject(new aggregateError(errors));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolvingCount++;\n\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst element = await nextItem.value;\n\t\t\t\t\tresult[index] = await mapper(element, index);\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tnext();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (stopOnError) {\n\t\t\t\t\t\tisRejected = true;\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors.push(error);\n\t\t\t\t\t\tresolvingCount--;\n\t\t\t\t\t\tnext();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t};\n\n\t\tfor (let i = 0; i < concurrency; i++) {\n\t\t\tnext();\n\n\t\t\tif (isIterableDone) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n};\n\nconst pMap$1 = (iterable, mapper, options) => new Promise((resolve, reject) => {\n\toptions = Object.assign({\n\t\tconcurrency: Infinity\n\t}, options);\n\n\tif (typeof mapper !== 'function') {\n\t\tthrow new TypeError('Mapper function is required');\n\t}\n\n\tconst {concurrency} = options;\n\n\tif (!(typeof concurrency === 'number' && concurrency >= 1)) {\n\t\tthrow new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t}\n\n\tconst ret = [];\n\tconst iterator = iterable[Symbol.iterator]();\n\tlet isRejected = false;\n\tlet isIterableDone = false;\n\tlet resolvingCount = 0;\n\tlet currentIndex = 0;\n\n\tconst next = () => {\n\t\tif (isRejected) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst nextItem = iterator.next();\n\t\tconst i = currentIndex;\n\t\tcurrentIndex++;\n\n\t\tif (nextItem.done) {\n\t\t\tisIterableDone = true;\n\n\t\t\tif (resolvingCount === 0) {\n\t\t\t\tresolve(ret);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tresolvingCount++;\n\n\t\tPromise.resolve(nextItem.value)\n\t\t\t.then(element => mapper(element, i))\n\t\t\t.then(\n\t\t\t\tvalue => {\n\t\t\t\t\tret[i] = value;\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tnext();\n\t\t\t\t},\n\t\t\t\terror => {\n\t\t\t\t\tisRejected = true;\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t);\n\t};\n\n\tfor (let i = 0; i < concurrency; i++) {\n\t\tnext();\n\n\t\tif (isIterableDone) {\n\t\t\tbreak;\n\t\t}\n\t}\n});\n\nvar pMap_1 = pMap$1;\n// TODO: Remove this for the next major release\nvar _default = pMap$1;\npMap_1.default = _default;\n\nconst pFilter = async (iterable, filterer, options) => {\n\tconst values = await pMap_1(\n\t\titerable,\n\t\t(element, index) => Promise.all([filterer(element, index), element]),\n\t\toptions\n\t);\n\treturn values.filter(value => Boolean(value[0])).map(value => value[1]);\n};\n\nvar pFilter_1 = pFilter;\n// TODO: Remove this for the next major release\nvar _default$1 = pFilter;\npFilter_1.default = _default$1;\n\nconst IS_ATOM = typeof atom !== 'undefined';\nconst IS_DEV = typeof atom !== 'undefined' && (atom.inDevMode() || atom.inSpecMode());\nconst IGNORED_CONFIG_NAME = 'atom-package-deps.ignored';\n\n/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nvar escapeHtml_1 = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\nasync function spawnInternal(command, args, options) {\n    const spawnedProcess = child_process.spawn(command, args, options);\n    const promise = new Promise((resolve, reject) => {\n        const output = {\n            stdout: spawnedProcess.stdout ? [] : null,\n            stderr: spawnedProcess.stderr ? [] : null,\n        };\n        spawnedProcess.on('error', reject);\n        if (spawnedProcess.stdout) {\n            spawnedProcess.stdout.on('data', function (chunk) {\n                output.stdout.push(chunk);\n                if (options.handleStdout) {\n                    options.handleStdout(chunk);\n                }\n            });\n        }\n        if (spawnedProcess.stderr) {\n            spawnedProcess.stderr.on('data', function (chunk) {\n                output.stderr.push(chunk);\n                if (options.handleStderr) {\n                    options.handleStderr(chunk);\n                }\n            });\n        }\n        spawnedProcess.on('close', code => {\n            let outputStdout = null;\n            if (output.stdout != null) {\n                outputStdout =\n                    options.encoding === null || options.encoding === 'buffer'\n                        ? Buffer.concat(output.stdout)\n                        : output.stdout.join('');\n            }\n            let outputStderr = null;\n            if (output.stderr != null) {\n                outputStderr =\n                    options.encoding === null || options.encoding === 'buffer'\n                        ? Buffer.concat(output.stderr)\n                        : output.stderr.join('');\n            }\n            resolve({\n                exitCode: code,\n                stdout: outputStdout,\n                stderr: outputStderr,\n            });\n        });\n    });\n    options.handleChildProcess(spawnedProcess);\n    return promise;\n}\nfunction spawn(command, args, options) {\n    let spawnedProcess;\n    const promise = spawnInternal(command, args, {\n        ...options,\n        handleChildProcess(_spawnedProcess) {\n            spawnedProcess = _spawnedProcess;\n        },\n    });\n    promise.kill = function (signal) {\n        // TODO: kill all subprocesses on windows with wmic?\n        return spawnedProcess.kill(signal);\n    };\n    return promise;\n}\n\nvar semverCompare = function cmp (a, b) {\n    var pa = a.split('.');\n    var pb = b.split('.');\n    for (var i = 0; i < 3; i++) {\n        var na = Number(pa[i]);\n        var nb = Number(pb[i]);\n        if (na > nb) return 1;\n        if (nb > na) return -1;\n        if (!isNaN(na) && isNaN(nb)) return 1;\n        if (isNaN(na) && !isNaN(nb)) return -1;\n    }\n    return 0;\n};\n\nasync function getDependencies(packageName) {\n  const packageModule = atom.packages.getLoadedPackage(packageName);\n  const packageDependencies = packageModule && packageModule.metadata['package-deps'];\n  return Array.isArray(packageDependencies) ? packageDependencies : [];\n}\nasync function resolveDependencyPath(packageName) {\n  return atom.packages.resolvePackagePath(packageName);\n}\nasync function getInstalledDependencyVersion(dependency) {\n  var _packageModule$metada;\n\n  const packageModule = atom.packages.getLoadedPackage(dependency.name);\n  return packageModule == null ? null : (_packageModule$metada = packageModule.metadata.version) !== null && _packageModule$metada !== void 0 ? _packageModule$metada : null;\n}\n\nasync function getDependencies$1(packageName) {\n  let packageStats = null;\n\n  try {\n    packageStats = await fs__default['default'].promises.stat(packageName);\n  } catch (_) {// No Op\n  }\n\n  if (packageStats == null || !packageStats.isDirectory()) {\n    throw new Error(`[Package-Deps] Expected packageName to be a readable directory in Node.js invocation`);\n  }\n\n  let parsed = null;\n\n  try {\n    const contents = await fs__default['default'].promises.readFile(path__default['default'].join(packageName, 'package.json'), 'utf8');\n    parsed = JSON.parse(contents);\n  } catch (_) {// Ignore JSON read errors and such\n  }\n\n  const packageDependencies = parsed == null || typeof parsed !== 'object' ? [] : parsed['package-deps'];\n  return Array.isArray(packageDependencies) ? packageDependencies : [];\n}\nasync function resolveDependencyPath$1(packageName) {\n  var _process$env$ATOM_HOM;\n\n  const packageDirectory = path__default['default'].join((_process$env$ATOM_HOM = process.env.ATOM_HOME) !== null && _process$env$ATOM_HOM !== void 0 ? _process$env$ATOM_HOM : path__default['default'].join(os__default['default'].homedir(), '.atom'), 'packages', packageName);\n\n  try {\n    await fs__default['default'].promises.access(packageDirectory, fs__default['default'].constants.R_OK);\n    return packageDirectory;\n  } catch (_) {\n    return null;\n  }\n}\nasync function getInstalledDependencyVersion$1(dependency) {\n  var _manifest$version, _manifest;\n\n  const {\n    directory\n  } = dependency;\n\n  if (directory == null) {\n    // Not possible to get version without resolved directory in Node.js version\n    return null;\n  }\n\n  let manifest = null;\n\n  try {\n    manifest = JSON.parse(await fs__default['default'].promises.readFile(path__default['default'].join(directory, 'package.json'), 'utf8'));\n  } catch (_) {\n    return null;\n  }\n\n  return (_manifest$version = (_manifest = manifest) === null || _manifest === void 0 ? void 0 : _manifest.version) !== null && _manifest$version !== void 0 ? _manifest$version : null;\n}\n\n/**\n * Internal helpers\n */\n\nasync function getInstalledDependencyVersion$2(dependency) {\n  if (IS_ATOM) {\n    const atomPackageVersion = await getInstalledDependencyVersion(dependency);\n\n    if (atomPackageVersion) {\n      return atomPackageVersion;\n    } // If the package isn't activated, it won't be loaded, so fallback to reading manifest file instead\n\n  }\n\n  return getInstalledDependencyVersion$1(dependency);\n}\n/**\n * Exported helpers\n */\n\n\nconst resolveDependencyPath$2 = IS_ATOM ? resolveDependencyPath : resolveDependencyPath$1;\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message !== null && message !== void 0 ? message : 'Invariant violation');\n  }\n}\nasync function getDependencies$2(name) {\n  const dependencies = await (IS_ATOM ? getDependencies(name) : getDependencies$1(name));\n\n  if (IS_DEV) {\n    invariant(Array.isArray(dependencies), `Dependencies for ${name} are not a valid array`);\n    dependencies.forEach((item, index) => {\n      if (Array.isArray(item)) {\n        item.forEach((subitem, subindex) => {\n          const invalidMessage = `Dependency#${index}#${subindex} for ${name} is invalid`;\n          invariant(typeof subitem.name === 'string' && subitem.name.length > 0, invalidMessage);\n          invariant(subitem.minimumVersion == null || typeof subitem.minimumVersion === 'string' && subitem.minimumVersion.length > 0, invalidMessage);\n        });\n        invariant(item.length > 0, `Dependency#${index} for ${name} has no group items`);\n      } else {\n        const invalidMessage = `Dependency#${index} for ${name} is invalid`;\n        invariant(typeof item.name === 'string' && item.name.length > 0, invalidMessage);\n        invariant(item.minimumVersion == null || typeof item.minimumVersion === 'string' && item.minimumVersion.length > 0, invalidMessage);\n      }\n    });\n  }\n\n  return dependencies;\n}\nasync function shouldInstallDependency(dependency) {\n  if (dependency.directory == null) {\n    // Not installed, so install\n    return true;\n  }\n\n  if (dependency.minimumVersion == null) {\n    // Already installed and no version defined, so skip\n    return false;\n  }\n\n  const version = await getInstalledDependencyVersion$2(dependency);\n\n  if (version == null) {\n    // Unable to get current version, so install\n    return true;\n  }\n\n  return semverCompare(dependency.minimumVersion, version) === 1;\n}\nfunction isPackageIgnored(name) {\n  var _atom$config$get;\n\n  if (!IS_ATOM) {\n    // Never ignored in CLI\n    return false;\n  }\n\n  const ignoredPackages = (_atom$config$get = atom.config.get(IGNORED_CONFIG_NAME)) !== null && _atom$config$get !== void 0 ? _atom$config$get : [];\n\n  if (ignoredPackages.includes(name)) {\n    return true;\n  } // If Atom \"notifications\" package is disabled, treat the whole thing as ignored\n\n\n  if (atom.packages.isPackageDisabled('notifications')) {\n    console.warn(`Enable notifications to install dependencies for ${name}`);\n    return true;\n  }\n\n  return false;\n}\nfunction markPackageAsIgnored(name) {\n  var _atom$config$get2;\n\n  if (!IS_ATOM) {\n    // No op in CLI\n    return;\n  }\n\n  const ignoredPackages = new Set((_atom$config$get2 = atom.config.get(IGNORED_CONFIG_NAME)) !== null && _atom$config$get2 !== void 0 ? _atom$config$get2 : []);\n  ignoredPackages.add(name);\n  atom.config.set(IGNORED_CONFIG_NAME, Array.from(ignoredPackages));\n}\nconst INSTALL_VALID_TICKS = new Set(['✓', 'done']);\nconst INSTALL_VALIDATION_REGEXP = /(?:Installing|Moving) (.*?) to .* (.*)/; // Example success output: Uninstalling linter-ui-default ✓\n\nasync function installPackage(dependency) {\n  const apmPath = IS_ATOM ? atom.packages.getApmPath() : 'apm';\n  const {\n    stdout,\n    stderr\n  } = await spawn(apmPath, ['install', dependency.name, '--production', '--color', 'false']);\n  const match = INSTALL_VALIDATION_REGEXP.exec(stdout.trim());\n\n  if (match != null && INSTALL_VALID_TICKS.has(match[2])) {\n    // Installation complete and verified\n    return;\n  }\n\n  const error = new Error(`Error installing dependency: ${dependency.name}`);\n  error.stack = stderr.trim();\n  throw error;\n}\n\nlet showResetInstruction = true;\nfunction confirmPackagesToInstall({\n  packageName,\n  dependencies\n}) {\n  return new Promise(resolve => {\n    const ungroupedDependencies = dependencies.filter(item => !Array.isArray(item));\n    const groupedDependencies = dependencies.filter(item => Array.isArray(item));\n    const skipGroups = groupedDependencies.length === 0;\n    const detail = skipGroups ? ungroupedDependencies.map(item => item.name).join(', ') : 'Something went wrong. Check your developer console';\n    const groupChoices = groupedDependencies.map(item => item[0]);\n    const notification = atom.notifications.addInfo(`${packageName} needs to install dependencies`, {\n      dismissable: true,\n      icon: 'cloud-download',\n      detail,\n      description: `Install dependenc${dependencies.length === 1 ? 'y' : 'ies'}?`,\n      buttons: [{\n        text: 'Yes',\n        onDidClick: () => {\n          if (skipGroups) {\n            resolve([]);\n          } else {\n            resolve(ungroupedDependencies.concat(groupChoices));\n          }\n\n          notification.dismiss();\n        }\n      }, {\n        text: 'No Thanks',\n        onDidClick: () => {\n          notification.dismiss();\n        }\n      }, {\n        text: 'Never',\n        onDidClick: () => {\n          markPackageAsIgnored(packageName);\n\n          if (showResetInstruction) {\n            showResetInstruction = false;\n            atom.notifications.addInfo('How to reset package-deps memory', {\n              dismissable: true,\n              description: \"To modify the list of ignored files invoke 'Application: Open Your Config' and change the 'atom-package-deps' section\"\n            });\n          }\n\n          notification.dismiss();\n        }\n      }]\n    });\n    notification.onDidDismiss(() => resolve([]));\n\n    if (skipGroups) {\n      return;\n    } // Handle groups\n\n\n    try {\n      var _notificationView$ele;\n\n      const notificationView = atom.views.getView(notification);\n      const notificationElement = (_notificationView$ele = notificationView === null || notificationView === void 0 ? void 0 : notificationView.element) !== null && _notificationView$ele !== void 0 ? _notificationView$ele : null;\n\n      if (notificationElement == null) {\n        throw new Error('Unable to get notification element from view');\n      }\n\n      const notificationContent = notificationElement.querySelector('.detail-content');\n\n      if (notificationContent == null) {\n        throw new Error('Content detail container not found inside the notification');\n      } // Clear the contents and add some skel\n\n\n      notificationContent.innerHTML = ''; // Add list of ungroup dependencies to the top of the notification\n\n      if (ungroupedDependencies.length > 0) {\n        const ungroupedLine = document.createElement('div');\n        ungroupedLine.innerHTML = `Packages without choices: <br /><ul><li>${ungroupedDependencies.map(item => escapeHtml_1(item.name)).join('</li><li>')}</li></ul>`;\n        notificationContent.appendChild(ungroupedLine);\n      } // Create a label line for groups\n\n\n      const groupLabelLine = document.createElement('div');\n      groupLabelLine.innerHTML = `Packages with choices:`;\n      notificationContent.appendChild(groupLabelLine); // Create one line per group with a select inside\n\n      const groupedList = document.createElement('ul');\n      groupedDependencies.forEach((item, index) => {\n        const listItem = document.createElement('li');\n        const select = document.createElement('select');\n        select.innerHTML = item.map(subitem => `<option>${escapeHtml_1(subitem.name)}</option>`).join('\\n');\n        select.addEventListener('change', () => {\n          // Change the selected value for this index for resolve to use\n          const subitem = item.find(entry => entry.name === select.value);\n\n          if (subitem != null) {\n            groupChoices[index] = subitem;\n          }\n        });\n        listItem.style.marginTop = '5px';\n        listItem.appendChild(select);\n        groupedList.appendChild(listItem);\n      });\n      notificationContent.appendChild(groupedList);\n    } catch (err) {\n      console.error('[Package-Deps] Error during showing package choices to user', err);\n    }\n  });\n}\nfunction getView({\n  packageName,\n  dependencies\n}) {\n  const failed = [];\n  const notification = atom.notifications.addInfo(`Installing ${packageName} dependencies`, {\n    detail: `Installing ${dependencies.map(item => item.name).join(', ')}`,\n    dismissable: true\n  });\n  const progress = document.createElement('progress');\n  progress.max = dependencies.length;\n  progress.style.width = '100%';\n\n  try {\n    var _notificationView$ele2;\n\n    const notificationView = atom.views.getView(notification);\n    const notificationElement = (_notificationView$ele2 = notificationView === null || notificationView === void 0 ? void 0 : notificationView.element) !== null && _notificationView$ele2 !== void 0 ? _notificationView$ele2 : null;\n\n    if (notificationElement == null) {\n      throw new Error('Unable to get notification element from view');\n    }\n\n    const notificationContent = notificationElement.querySelector('.detail-content');\n\n    if (notificationContent == null) {\n      throw new Error('Content detail container not found inside the notification');\n    }\n\n    notificationContent.appendChild(progress);\n  } catch (err) {\n    console.error('[Package-Deps] Error during showing installation progress to user', err);\n  }\n\n  return {\n    handleFailure({\n      dependency,\n      error\n    }) {\n      var _error$stack;\n\n      failed.push(dependency.name);\n      progress.value += 1;\n      console.error(`[Package-Deps] Unable to install ${dependency.name}, Error:`, (_error$stack = error === null || error === void 0 ? void 0 : error.stack) !== null && _error$stack !== void 0 ? _error$stack : error);\n    },\n\n    handleDependencyInstalled(dependency) {\n      progress.value += 1;\n    },\n\n    handleComplete() {\n      notification.dismiss();\n\n      if (failed.length > 0) {\n        atom.notifications.addWarning(`Failed to install ${packageName} dependencies`, {\n          detail: `These packages were not installed, check your console\\nfor more info.\\n${failed.join('\\n')}`,\n          dismissable: true\n        });\n      } else {\n        atom.notifications.addSuccess(`Installed ${packageName} dependencies`, {\n          detail: `Installed ${dependencies.map(item => item.name).join(', ')}`\n        });\n      }\n\n      Promise.all(dependencies.map(item => {\n        if (!failed.includes(item.name)) {\n          return atom.packages.activatePackage(item.name);\n        }\n\n        return null;\n      })).catch(err => {\n        console.error(`[Package-Deps] Error activating installed packages for ${packageName}`, err);\n      });\n    }\n\n  };\n}\n\nasync function confirmPackagesToInstall$1({\n  dependencies\n}) {\n  // No user interaction on the CLI. Install the first (aka \"default\" choice) package\n  return dependencies.map(item => Array.isArray(item) ? item[0] : item);\n}\nfunction getView$1({\n  dependencies\n}) {\n  let failed = false;\n  console.log(`Installing dependencies:\\n${dependencies.map(item => `  - ${item.name}`).join('\\n')}`);\n  return {\n    handleFailure({\n      dependency,\n      error\n    }) {\n      var _error$stack;\n\n      failed = true;\n      console.error(`Unable to install ${dependency.name}, Error:`, (_error$stack = error === null || error === void 0 ? void 0 : error.stack) !== null && _error$stack !== void 0 ? _error$stack : error);\n    },\n\n    handleDependencyInstalled(dependency) {\n      console.log('Successfully installed', dependency.name);\n    },\n\n    handleComplete() {\n      console.log('Installation complete');\n\n      if (failed) {\n        // Fail the invocation\n        process.exitCode = 1;\n      }\n    }\n\n  };\n}\n\nconst getView$2 = IS_ATOM ? getView : getView$1;\nconst confirmPackagesToInstall$2 = IS_ATOM ? confirmPackagesToInstall : confirmPackagesToInstall$1;\n\nasync function install(packageName) {\n  invariant(typeof packageName === 'string' && packageName.length > 0, '[Package-Deps] Package name is required');\n\n  if (isPackageIgnored(packageName)) {\n    // User ignored this package\n    return;\n  } // Get list of relevant dependencies\n\n\n  const dependencies = await getDependencies$2(packageName);\n\n  if (dependencies.length === 0) {\n    // Short-circuit\n    return;\n  } // Resolve directories of relevant dependencies\n\n\n  const resolvedDependencies = await Promise.all(dependencies.map(async item => {\n    if (Array.isArray(item)) {\n      return Promise.all(item.map(async subitem => ({ ...subitem,\n        directory: await resolveDependencyPath$2(subitem.name)\n      })));\n    }\n\n    return { ...item,\n      directory: await resolveDependencyPath$2(item.name)\n    };\n  })); // Filter out already installed, in range dependencies\n  // If one dependency from a group is already installed, whole group is ignored\n\n  const dependenciesToInstall = await pFilter_1(resolvedDependencies, async function (item) {\n    if (Array.isArray(item)) {\n      return (await Promise.all(item.map(subitem => shouldInstallDependency(subitem)))).every(Boolean);\n    }\n\n    return shouldInstallDependency(item);\n  });\n\n  if (dependenciesToInstall.length === 0) {\n    // Short-circuit if all have been skipped\n    return;\n  }\n\n  const chosenDependencies = await confirmPackagesToInstall$2({\n    packageName,\n    dependencies: dependenciesToInstall\n  });\n\n  if (chosenDependencies.length === 0) {\n    // Short-circuit if user interaction cancelled all\n    return;\n  }\n\n  const view = getView$2({\n    packageName,\n    dependencies: chosenDependencies\n  });\n  await pMap(chosenDependencies, async function (dependency) {\n    try {\n      await installPackage(dependency);\n      view.handleDependencyInstalled(dependency);\n    } catch (err) {\n      view.handleFailure({\n        dependency,\n        error: err\n      });\n    }\n  }, {\n    concurrency: 2\n  });\n  view.handleComplete();\n}\n\nexports.install = install;\n","module.exports = require(\"fs\");;","module.exports = require(\"path\");;","'use strict';\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.satisfyDependencies = void 0;\nvar atom_package_deps_1 = require(\"atom-package-deps\");\nvar atom_read_manifest_1 = require(\"atom-read-manifest\");\nvar defaultOptions = {\n    logger: console.log\n};\n/**\n * Installs and optionally enables package dependencies\n * @param {string} identifier\n * @param {Object} options\n */\nfunction satisfyDependencies(identifier, userOptions) {\n    if (userOptions === void 0) { userOptions = {}; }\n    return __awaiter(this, void 0, void 0, function () {\n        var options, manifest;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    options = __assign(__assign({}, defaultOptions), userOptions);\n                    return [4 /*yield*/, atom_read_manifest_1.readManifest(identifier)];\n                case 1:\n                    manifest = _a.sent();\n                    return [4 /*yield*/, atom_package_deps_1.install(manifest['name'])];\n                case 2:\n                    _a.sent();\n                    enableDependencies(manifest['package-deps'], options);\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.satisfyDependencies = satisfyDependencies;\n/**\n * Enables packages dependencies\n * @param {Object} manifest\n * @param {Object} options\n */\nfunction enableDependencies(manifest, options) {\n    if (options.enableDependencies) {\n        manifest['package-deps'].map(function (packageDependency) {\n            if (atom.packages.isPackageDisabled(packageDependency)) {\n                if (atom.inDevMode()) {\n                    options.logger(\"[\" + manifest.name + \"] Enabling package dependency '\" + packageDependency + \"'\");\n                }\n                atom.packages.enablePackage(packageDependency);\n            }\n        });\n    }\n}\n//# sourceMappingURL=index.js.map","'use strict';\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readManifestSync = exports.readManifest = void 0;\nvar _a = require('path'), resolve = _a.resolve, sep = _a.sep;\nvar _b = require('fs'), fs = _b.promises, readFileSync = _b.readFileSync;\nvar callerCallsite = require('caller-callsite');\nfunction readManifest(packageName) {\n    if (packageName === void 0) { packageName = ''; }\n    return __awaiter(this, void 0, void 0, function () {\n        var filePath, fileContents, err_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    filePath = resolveFilePath(packageName);\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, fs.readFile(filePath, 'utf8')];\n                case 2:\n                    fileContents = _a.sent();\n                    return [2 /*return*/, JSON.parse(fileContents)];\n                case 3:\n                    err_1 = _a.sent();\n                    return [2 /*return*/, null];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.readManifest = readManifest;\nfunction readManifestSync(packageName) {\n    if (packageName === void 0) { packageName = ''; }\n    var filePath = resolveFilePath(packageName);\n    try {\n        var fileContents = readFileSync(filePath, 'utf8');\n        return JSON.parse(fileContents);\n    }\n    catch (err) {\n        return null;\n    }\n}\nexports.readManifestSync = readManifestSync;\nfunction resolveFilePath(packageName) {\n    packageName = (packageName === null || packageName === void 0 ? void 0 : packageName.length) ? packageName : getPackageName();\n    var packagePath = atom.packages.resolvePackagePath(packageName);\n    var filePath = resolve(packagePath, 'package.json');\n    return filePath;\n}\nfunction getPackageName() {\n    var callerPath = callerCallsite().getFileName();\n    var packageDirPaths = atom.packages.getPackageDirPaths();\n    var intersection = packageDirPaths.filter(function (packageDirPath) {\n        return callerPath.startsWith(packageDirPath);\n    });\n    if (intersection === null || intersection === void 0 ? void 0 : intersection.length) {\n        return callerPath\n            .replace(intersection[0], '')\n            .split(sep)\n            .filter(function (fragment) { return fragment; })[0] || '';\n    }\n    return '';\n}\n//# sourceMappingURL=index.js.map","'use strict';\nconst callsites = require('callsites');\n\nmodule.exports = ({depth = 0} = {}) => {\n\tconst callers = [];\n\tconst callerFileSet = new Set();\n\n\tfor (const callsite of callsites()) {\n\t\tconst fileName = callsite.getFileName();\n\t\tconst hasReceiver = callsite.getTypeName() !== null && fileName !== null;\n\n\t\tif (!callerFileSet.has(fileName)) {\n\t\t\tcallerFileSet.add(fileName);\n\t\t\tcallers.unshift(callsite);\n\t\t}\n\n\t\tif (hasReceiver) {\n\t\t\treturn callers[depth];\n\t\t}\n\t}\n};\n","'use strict';\n\nconst callsites = () => {\n\tconst _prepareStackTrace = Error.prepareStackTrace;\n\tError.prepareStackTrace = (_, stack) => stack;\n\tconst stack = new Error().stack.slice(1);\n\tError.prepareStackTrace = _prepareStackTrace;\n\treturn stack;\n};\n\nmodule.exports = callsites;\n// TODO: Remove this for the next major release\nmodule.exports.default = callsites;\n","import { platform } from 'os';\n\nexport function which() {\n  return platform() === 'win32' ? 'where' : 'which';\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => module['default'] :\n\t\t() => module;\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(0);\n"],"sourceRoot":""}